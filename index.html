<!DOCTYPE html>
<html><head>
    <meta charset='utf-8'>
    <style>
        * { margin: 0; padding: 0; border: none; overflow: hidden; width:100%; height:100% }
    </style>
    <script type="text/javascript">
		if(typeof String.prototype.startsWith != 'function') {
			String.prototype.startsWith = function (str){ return this.slice(0, str.length) == str }
		}
		if(typeof(String.prototype.trim) != 'function') {
			String.prototype.trim = function()  { return String(this).replace(/^\s+|\s+$/g, '') }
		}
        function setupGL(canvas) {
            var gl = surface.getContext("webgl") || surface.getContext("experimental-webgl")
            if(!gl) throw new Error("no webgl context")
            surface.gl = gl
            window.onresize = function() {
				var surf = getSurf()
				var w = surf.clientWidth; var h = surf.clientHeight;
				if(!gl.w || gl.w != w || gl.h != h) {
					gl.w = w; gl.h = h
					surf.width = w
					surf.height = h
					console.log("resize " + w + " x " + h + " => ")
					resize(gl)
					step()
				}
			}
			window.onmousemove = function(e) {
				if(window.draging) {
					var deltaX = e.x - window.dragX
					var deltaY = e.y - window.dragY
					gl.scroll(deltaX - window.deltaX, deltaY - window.deltaY)
					window.deltaX = deltaX
					window.deltaY = deltaY
				}
			}
			window.onmousedown = function(e) {
				window.dragX = e.x
				window.dragY = e.y
				window.deltaX = 0
				window.deltaY = 0
				window.draging = true
			}
			window.onmouseup = function(e) { window.draging = false }
			window.onwheel = function(e) { gl.zoom(Math.sign(e.wheelDelta), e.x, e.y) }
        }
        function getEl(id) {
			var r = document.getElementById(id)
			if(!r) throw new Error("element [" + id + "] not found")
			return r
		}
        function getSurf() { return getEl("surface") }
        function getGl() {
			var surface = getSurf();
			if(!surface.gl) setupGL(surface);
			return surface.gl;
		}
		function getQuad(gl) {
			if(!gl.quad) {
				var bufId = gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER, bufId)
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 0,1, 1,1, 1,0]), gl.STATIC_DRAW)
				gl.quad = function(posAttrib) {
					gl.bindBuffer(gl.ARRAY_BUFFER, bufId)
					gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0)
					gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
				}
			}
			return gl.quad
		}
		function compile(s) {
			if(!s.shader) {
				var gl = getGl();
				var shader;
				if(s.type == "x-shader/x-vertex") shader = gl.createShader(gl.VERTEX_SHADER);
				else if(s.type == "x-shader/x-fragment") shader = gl.createShader(gl.FRAGMENT_SHADER);
				else return null;
				var src = '';
				for(c = s.firstChild; c; c = c.nextSibling) if(c.nodeType == c.TEXT_NODE) src += c.textContent;
				var vars = [];
				src.split('\n').forEach(function(line) {
					var parts = line.split("//");
					//var lastArray = parts.length > 1 && parts[1].trim() == "array";
					parts[0].split(";").forEach(function(statement) {
						var words = statement.split(/[^a-zA-Z0-9]/).filter(function(w) { return w.trim() });
						if(words[0] == "attribute") vars = vars.concat([{
							name : words[words.length-1],
							array: words.indexOf("array") >= 0,
							type : 'attribute'
						}])
						else if(words[0] == "uniform") vars = vars.concat([{
							name : words[words.length-1],
							type : 'uniform'
						}])
					})
				})
				gl.shaderSource(shader, src);
				gl.compileShader(shader);
				if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
					throw new Error("error in shader [" + s.id + "]\n" + gl.getShaderInfoLog(shader));
				s.shader = shader;
				s.vars = vars;
				console.log("shader compiled: " + s.id + " => " + JSON.stringify(s.vars))
			}
			return s;
		}
        function entry() {
            var gl = getGl();
			gl.program = function(shaders) {
				if(!gl.progCache) gl.progCache = {}
				var key = shaders.toString();
				if(!gl.progCache[key]) {
					var prog = gl.createProgram();
					var vars = []
					shaders.forEach(function(s) {
						var shader = compile(getEl(s));
						vars = vars.concat(shader.vars)
						gl.attachShader(prog, shader.shader)
					})
					gl.linkProgram(prog)
					if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error("error in program [" + key + "]\n" + gl.getProgramInfoLog(prog));
					gl.useProgram(prog)
					prog.vars = {}
					vars.forEach(function(v) {
						if(v.type == 'attribute') {
							prog.vars[v.name] = gl.getAttribLocation(prog, v.name)
							if(v.array) gl.enableVertexAttribArray(prog, prog.vars[v.name]);
						} else if(v.type == 'uniform') {
							prog.vars[v.name] = gl.getUniformLocation(prog, v.name)
						}
						if(typeof(prog[v.name]) == "undefined") prog[v.name] = prog.vars[v.name]
					})
					console.log("progam linked: " + key + " => " + JSON.stringify(prog.vars))
					gl.progCache[key] = prog
				} else gl.useProgram(gl.progCache[key])
				return gl.progCache[key]
			}
			init(gl)
			window.onresize()
        }
        function step() {
			draw(getGl())
			requestAnimationFrame(step)
        }
        
        /*function() {
			gl.
        }*/
		
		var config = {
			width: 1024,
			height: 1024,
			init: {
				density: 0.1,
				min_score: 100,
				max_score: 1000,
			},
			dna : [
				{
					name: "herbivore",
					init_energy: 0.4
				},
				{
					name: "carnivore",
					init_energy: 0.8
				}
			]
		}
        
		function init(gl) {
			gl.clearColor(0,0,0,1)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
			if(!(gl.draw_buffers = gl.getExtension("WEBGL_draw_buffers"))) throw new Error("no draw_buffers")
			if(!(gl.draw_buffers = gl.getExtension("WEBGL_depth_texture"))) throw new Error("no depth_texture")
			
			var n = config.width * config.height | 0
			var dna_init = new Uint8Array(new ArrayBuffer(n))
			var ep_init = new Float32Array(new ArrayBuffer(n * 4 * 2))
			var score_min = config.init.min_score | 0
			var score_delta = (config.init.max_score - config.init.min_score) | 0
			for(var i = 0; i ; i < n) {
				if(Math.random() <= config.init.density) {
					dna_init[i] = Math.floor(Math.random() * config.dna.length) | 0
					var score = score_min + score_delta * Math.random()
					var e = init.config.dna[dna_init[i]].init_energy
					ep_init[2 * i] = Math.floor(score * e)
					ep_init[2*i+1] = Math.floor(score * (1-e))
				} else {
					dna_init[i] = 0
					ep_init[2 * i] = ep_init[2*i+1] = 0
				}
			}
			gl.camera = new Float32Array([0, 0, 1])
			gl.scroll = function(x,y) {
				gl.camera[0] -= x / gl.canvas.width
				gl.camera[1] += y / gl.canvas.height
			}
			gl.zoom = function(s, x,y) {
				var m = 1.1
				m = s == 0 ? 1 : s > 0 ? 1/m : m
				gl.camera[0] += (1-m) * x / gl.canvas.width
				gl.camera[1] += (1-m) * (1 - y / gl.canvas.height)
				gl.camera[0] /= m
				gl.camera[1] /= m
				gl.camera[2] *= m
			}
			gl.content = {}
			gl.bindTexture(gl.TEXTURE_2D, gl.content.dna_tex = gl.createTexture())
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, config.width, config.height, 0, gl.ALPHA, gl.GL_UNSIGNED_BYTE, dna_init)
			
			gl.bindTexture(gl.TEXTURE_2D, gl.content.ep_tex = gl.createTexture())
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, config.width, config.height, 0, gl.GL_LUMINANCE_ALPHA, gl.GL_FLOAT, ep_init)
			
			/*gl.screen = gl.createFramebuffer()
			gl.bindFramebuffer()
			gl.framebufferTexture2d()
			
			gl.genRenderbuffers(1)
			gl.framebufferRenderbuffer()*/
			
			//console.log(getGl().getSupportedExtensions())
		}
		function resize(gl) {
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
		}
        function draw(gl) {
			//gl.clear(gl.COLOR_BUFFER_BIT)
			var prog = gl.program(["identity", "white"])
			gl.uniform1f(prog.time, performance.now())
			gl.uniform3fv(prog.camera, gl.camera)
			getQuad(gl)(prog.posIn)
		}
    </script>
	<script type="x-shader/x-vertex" id="identity">
		uniform mediump float time;
		attribute vec2 /* array */ posIn;
		varying mediump vec2 pos;
		void main(void) {
			pos = posIn;
			gl_Position = vec4(posIn * vec2(2) - vec2(1), vec2(0,1));
		}
	</script>
	<script type="x-shader/x-fragment" id="white">
		varying mediump vec2 pos;
		uniform mediump vec3 camera;
		void main(void) {
			//gl_FragCoord
			gl_FragColor = vec4(sin(vec2(10) * (pos + camera.xy) * camera.z), sin((pos.x+camera.x) * camera.z), 1);
		}
	</script>

</head><body onload="entry()">
    <canvas id="surface">
        No WebGL!
    </canvas>
</body></html>
