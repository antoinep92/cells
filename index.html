<!DOCTYPE html>
<html><head>
    <meta charset='utf-8'>
    <style>
        * { margin: 0; padding: 0; border: none; overflow: hidden; width:100%; height:100% }
    </style>
    <script type="text/javascript">
		if(typeof String.prototype.startsWith != 'function') {
			String.prototype.startsWith = function (str){ return this.slice(0, str.length) == str }
		}
		if(typeof(String.prototype.trim) != 'function') {
			String.prototype.trim = function()  { return String(this).replace(/^\s+|\s+$/g, '') }
		}
        function setupGL(canvas) {
            var gl = surface.getContext("webgl") || surface.getContext("experimental-webgl")
            if(!gl) throw new Error("no webgl context")
            surface.gl = gl
            window.onresize = function() {
				var surf = getSurf()
				var w = surf.clientWidth; var h = surf.clientHeight;
				if(!gl.w || gl.w != w || gl.h != h) {
					gl.w = w; gl.h = h
					surf.width = w
					surf.height = h
					//console.log("resize " + w + " x " + h + " => ")
					resize(gl)
					step()
				}
			}
			window.onmousemove = function(e) {
				if(window.draging) {
					var deltaX = e.x - window.dragX
					var deltaY = e.y - window.dragY
					gl.scroll(deltaX - window.deltaX, deltaY - window.deltaY)
					window.deltaX = deltaX
					window.deltaY = deltaY
				}
			}
			window.onmousedown = function(e) {
				window.dragX = e.x
				window.dragY = e.y
				window.deltaX = 0
				window.deltaY = 0
				window.draging = true
			}
			window.onmouseup = function(e) { window.draging = false }
			window.onwheel = function(e) { gl.zoom(Math.sign(e.wheelDelta), e.x, e.y) }
        }
        function getEl(id) {
			var r = document.getElementById(id)
			if(!r) throw new Error("element [" + id + "] not found")
			return r
		}
        function getSurf() { return getEl("surface") }
        function getGl() {
			var surface = getSurf();
			if(!surface.gl) setupGL(surface);
			return surface.gl;
		}
		function getQuad(gl) {
			if(!gl.quad) {
				var bufId = gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER, bufId)
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 0,1, 1,1, 1,0]), gl.STATIC_DRAW)
				gl.quad = function(posAttrib) {
					gl.bindBuffer(gl.ARRAY_BUFFER, bufId)
					gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0)
					gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
				}
			}
			return gl.quad
		}
		function compile(s) {
			if(!s.shader) {
				var gl = getGl();
				var shader;
				if(s.type == "x-shader/x-vertex") shader = gl.createShader(gl.VERTEX_SHADER);
				else if(s.type == "x-shader/x-fragment") shader = gl.createShader(gl.FRAGMENT_SHADER);
				else return null;
				var src = '';
				for(c = s.firstChild; c; c = c.nextSibling) if(c.nodeType == c.TEXT_NODE) src += c.textContent;
				var vars = []
				src.replace(/\/\/.*$/mg, '').replace(/\/\*.*\*\//g, '').replace(/^.*#.*/mg, '').split(';').forEach(function(statement) {
						var words = statement.split(/[^a-zA-Z0-9]/)
							.map(function(w) { return w.trim() })
							.filter(function(w) { return w != '' })
							.filter(function(w) { return ["const", "int", "float", "vec2", "vec3", "vec4", "sampler2D"].indexOf(w) < 0 })
						if(["uniform", "attribute"].indexOf(words[0]) >= 0) for(var i = 1; i < words.length; i++) vars.push({
							type: words[0],
							name: words[i]
						})
				})
				src = "precision mediump float;" +
					src	.replace(/\$pi2/g, Math.PI * 2)
						.replace(/\$pi/g, Math.PI)
						.replace(/\$invWidth/g, 1/config.width)
						.replace(/\$invHeight/g, 1/config.height)
						.replace(/\$invSize/g, "vec2(" + 1/config.width + ", " + 1/config.height + ")")
				gl.shaderSource(shader, src)
				gl.compileShader(shader)
				if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
					throw new Error("error in shader [" + s.id + "]\n" + gl.getShaderInfoLog(shader) + "\n" + src)
				s.shader = shader
				s.vars = vars
				//console.log("shader compiled: " + s.id + " => " + JSON.stringify(s.vars))
			}
			return s;
		}
        function entry() {
            var gl = getGl();
			gl.program = function(shaders) {
				if(!gl.progCache) gl.progCache = {}
				var key = shaders.toString();
				if(!gl.progCache[key]) {
					var prog = gl.createProgram();
					var vars = []
					shaders.forEach(function(s) {
						var shader = compile(getEl(s));
						vars = vars.concat(shader.vars)
						gl.attachShader(prog, shader.shader)
					})
					gl.linkProgram(prog)
					if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error("error in program [" + key + "]\n" + gl.getProgramInfoLog(prog));
					gl.useProgram(prog)
					prog.vars = {}
					vars.forEach(function(v) {
						if(v.type == 'attribute') {
							prog.vars[v.name] = gl.getAttribLocation(prog, v.name)
							gl.enableVertexAttribArray(prog, prog.vars[v.name]);
						} else if(v.type == 'uniform') {
							prog.vars[v.name] = gl.getUniformLocation(prog, v.name)
						}
						if(typeof(prog[v.name]) == "undefined") prog[v.name] = prog.vars[v.name]
					})
					//console.log("progam linked: " + key + " => " + JSON.stringify(prog.vars))
					gl.progCache[key] = prog
				} else gl.useProgram(gl.progCache[key])
				return gl.progCache[key]
			}
			init(gl)
			window.onresize()
        }
        function step() {
			draw(getGl())
			requestAnimationFrame(step)
        }
        
        /*function() {
			gl.
        }*/
		
		var config = {
			width: 1024,
			height: 1024,
			food_gen: 1,
			init: {
				density: 0.1,
				min_score: 30,
				max_score: 100,
				min_food: 50,
				max_food: 150
			},
			species : [
				{
					name: "plant"
				},
				{
					name: "sheep"
				},
				{
					name: "wolf"
				}
			]
		}
        
		function init(gl) {
			gl.clearColor(0,0,0,1)
			if(!(gl.draw_buffers = gl.getExtension("WEBGL_draw_buffers"))) throw new Error("no draw_buffers")
			if(!(gl.frag_depth = gl.getExtension("EXT_frag_depth"))) throw new Error("no frag_depth")
			if(!(gl.depth_texture = gl.getExtension("WEBGL_depth_texture"))) throw new Error("no depth_texture")
			if(!(gl.texture_float = gl.getExtension("OES_texture_float"))) throw new Error("no texture_float")
			if(!(gl.texture_half_float = gl.getExtension("OES_texture_half_float"))) throw new Error("no texture_half_float")
			
			gl.camera = new Float32Array([0, 0, 20])
			gl.scroll = function(x,y) {
				gl.camera[0] -= x
				gl.camera[1] += y
			}
			gl.zoom = function(s, x,y) {
				var m = 1.1
				m = s == 0 ? 1 : s > 0 ? m : 1/m
				var target = gl.camera[2] * m
				if(target < 1) {
					target = 1
					m = target / gl.camera[2]
				}
				if(target > 150) {
					target = 150
					m = target / gl.camera[2]
				}
				gl.camera[2] = target
				s = 1 - 1/m
				gl.camera[0] += s * x
				gl.camera[1] += s * (gl.canvas.height - y)
				gl.camera[0] *= m
				gl.camera[1] *= m
			}
			gl.content = {}
			
			var n = config.width * config.height | 0
			var background = new Uint8Array(new ArrayBuffer(n * 4)) // [ food, ?, ?, ? ]
			var cells = new Uint8Array(new ArrayBuffer(n * 4)) // [ species, state, energy, protect ]
			var entropy = new Uint8Array(new ArrayBuffer(n * 4))
			var score_min = config.init.min_score * .5, score_delta = (config.init.max_score - config.init.min_score) * .5
			var food_min = config.init.min_food, food_delta = (config.init.max_food - config.init.min_food)
			for(var i = 0; i < n; i++) {
				if(Math.random() <= config.init.density) {
					var c = Math.floor(Math.random() * config.species.length) | 0
					cells[4*i] = c + 1 | 0
					cells[4*i+1] = cells[4*i+2] = score_min + score_delta * Math.random()
				}
				background[4*i] = food_min + Math.random() * food_delta
				entropy[4*i  ] = Math.random() * 256
				entropy[4*i+1] = Math.random() * 256
				entropy[4*i+2] = Math.random() * 256
				entropy[4*i+3] = Math.random() * 256
			}
			
			function setLinear() {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
			}
			function setNearest() {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
			}
			function setRepeat() {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
			}
			
			gl.bindTexture(gl.TEXTURE_2D, gl.content.entropy = gl.createTexture())
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, config.width, config.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, entropy)
			setNearest(); setRepeat();
			
			gl.content.background = [null, null]
			for(i = 0; i < 2; i++) {
				gl.bindTexture(gl.TEXTURE_2D, gl.content.background[i] = gl.createTexture())
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, config.width, config.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, background)
				setNearest(); setRepeat()
			}
			
			gl.content.cells = [null, null]
			for(i = 0; i < 2; i++) {
				gl.bindTexture(gl.TEXTURE_2D, gl.content.cells[i] = gl.createTexture())
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, config.width, config.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, cells)
				setNearest(); setRepeat()
			}
			
			gl.content.to_cells = [null, null]
			for(i = 0; i < 2; i++) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, gl.content.to_cells[i] = gl.createFramebuffer())
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.draw_buffers.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, gl.content.background[i], 0)
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.draw_buffers.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, gl.content.cells[i], 0)
				if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) throw new Error("unsupported FBO config")
			}
			gl.content.flip = 0
			gl.bindFramebuffer(gl.FRAMEBUFFER, null)
			
			//console.log(getGl().getSupportedExtensions())
		}
		function resize(gl) {
			//gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
		}
        function draw(gl) {
			var flip = gl.content.flip, flop = 1 - flip;
			
			// [ background, cells ][flop] => [ background, cells ][flip]
			gl.bindFramebuffer(gl.FRAMEBUFFER, gl.content.to_cells[flip])
			gl.viewport(0, 0, config.width, config.height)
			gl.draw_buffers.drawBuffersWEBGL([ gl.draw_buffers.COLOR_ATTACHMENT0_WEBGL, gl.draw_buffers.COLOR_ATTACHMENT1_WEBGL ])
			var prog = gl.program(["2d", "move-test"])
			gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, gl.content.background[flop]); gl.uniform1i(prog.background, 0)
			gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, gl.content.cells[flop]); gl.uniform1i(prog.cells, 1)
			gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, gl.content.entropy); gl.uniform1i(prog.entropy, 2)
			gl.uniform2f(prog.seed, Math.random(), Math.random())
			getQuad(gl)(prog.posIn)
			
			// [ background, cells ][flip] => screen
			gl.bindFramebuffer(gl.FRAMEBUFFER, null)
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
			var prog = gl.program(["2d", "draw"])
			gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, gl.content.background[flip]); gl.uniform1i(prog.background, 0)
			gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, gl.content.cells[flip]); gl.uniform1i(prog.cells, 1)
			gl.uniform1f(prog.time, performance.now())
			gl.uniform3fv(prog.camera, gl.camera)
			getQuad(gl)(prog.posIn)
			
			gl.content.flip = flop
		}
    </script>
	<script type="x-shader/x-vertex" id="2d">
		uniform float time;
		attribute vec2 /* array */ posIn;
		void main(void) {
			gl_Position = vec4(posIn * vec2(2) - vec2(1), vec2(0,1));
		}
	</script>
	<script type="x-shader/x-fragment" id="draw">
		uniform vec3 camera;
		uniform sampler2D background, cells;
		vec3 hue(float h) {
			return clamp(vec3(
				6.0 * abs(h-.5) - 1.0,
				2.0 - 6.0 * abs(h - .33333333333333),
				2.0 - 6.0 * abs(h - .66666666666667)
			), 0., 1.);
		}
		void main(void) {
			//gl_FragCoord
			vec2 trans = (gl_FragCoord.xy + camera.xy) / camera.z;
			
			vec2 grid1 = step( 1. - .2/camera.z, cos(trans * $pi2) );
			vec2 grid10 = step( 1. - .05/camera.z, cos(trans * .1*$pi2) );
			vec2 grid100 = step( 1. - .01/camera.z, cos(trans * .01*$pi2) );
			vec2 grid2 = grid100 * grid10 + grid10 * clamp(.1 * (camera.z - 4.), 0., 1.) + grid1 * clamp(.01 * (camera.z - 50.), 0., 1.);
			float grid = min(1., grid2.x + grid2.y);
			
			vec2 texCoord = trans * $invSize;
			vec4 bg = texture2D(background, texCoord);
			vec4 cell = texture2D(cells, texCoord);
			vec3 color;
			if(cell.r != 0.) { // draw cell
				color = hue(fract(cell.r * 70.));
				vec3 fill = color * cell.b;
				if(max(abs(fract(trans.x) - .5), abs(fract(trans.y) - .5)) > (.5 - cell.a * .5)) { // border
					color = mix(fill, (color + 1.) * .5, clamp((camera.z - 20.) * .02, 0., 1.));
				} else { // fill
					color = fill;
				}
				//color =  * min(value, .5) * 2. + max(value - .5, 0.0) * vec3(2.0);
			} else { // draw food
				float fill = bg.r * .5;
				if(camera.z > 15.) {
					float pattern = mod(floor(trans.x) + floor(trans.y), 2.) == 0. ? trans.x + trans.y : trans.x - trans.y;
					pattern = .5 + .5 * cos(pattern * $pi2 * 3.);
					pattern = bg.r < .5 ? .25 * step(pattern, bg.r * 2.) : .25 + .25 * step(bg.r * 2. - 1., pattern);
					color = vec3(mix(fill, pattern, min((camera.z - 15.) * .01, 1.)));
				} else color = vec3(fill);
			}
			gl_FragColor = vec4(vec3(color + vec3(grid * .4)), 1);
		}
	</script>
	<script type="x-shader/x-fragment" id="move-test">
		#extension GL_EXT_draw_buffers : require
		uniform sampler2D background, cells, entropy;
		uniform vec2 seed;
		vec4 rand(vec2 where) { return texture2D(entropy, where + seed); }
		const float one = 1./255.;
		vec2 rand_move(vec2 where) {
			vec4 rnd = rand(where);
			if(rnd.r > .5) return vec2(0.);
			if(rnd.g > .5) return vec2(rnd.b > .5 ? -$invWidth : $invWidth, 0.);
			return vec2(0., rnd.b > .5 ? -$invHeight : $invHeight);
		}
		void main(void) {
			vec2 pos = gl_FragCoord.xy * $invSize;
			gl_FragData[0] = texture2D(background, pos) + vec4(0, 0., 0., 0.); // background out
			gl_FragData[1] = texture2D(cells, pos + rand_move(pos)); // cells out
		}
	</script>

</head><body onload="entry()">
    <canvas id="surface">
        No WebGL!
    </canvas>
</body></html>
