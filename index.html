<!DOCTYPE html>
<html><head>
    <meta charset='utf-8'>
    <style>
        * { margin: 0; padding: 0; border: none; overflow: hidden; width:100%; height:100% }
    </style>
    <script type="text/javascript">
		if(typeof String.prototype.startsWith != 'function') {
			String.prototype.startsWith = function (str){ return this.slice(0, str.length) == str }
		}
		if(typeof(String.prototype.trim) != 'function') {
			String.prototype.trim = function()  { return String(this).replace(/^\s+|\s+$/g, '') }
		}
        function setupGL(canvas) {
            var gl = surface.getContext("webgl") || surface.getContext("experimental-webgl")
            if(!gl) throw new Error("no webgl context")
            surface.gl = gl
            window.onresize = function() {
				var surf = getSurf()
				var w = surf.clientWidth; var h = surf.clientHeight;
				if(!gl.w || gl.w != w || gl.h != h) {
					gl.w = w; gl.h = h
					surf.width = w
					surf.height = h
					//console.log("resize " + w + " x " + h + " => ")
					resize(gl)
					step()
				}
			}
			window.onmousemove = function(e) {
				if(window.draging) {
					var deltaX = e.x - window.dragX
					var deltaY = e.y - window.dragY
					gl.scroll(deltaX - window.deltaX, deltaY - window.deltaY)
					window.deltaX = deltaX
					window.deltaY = deltaY
				}
			}
			window.onmousedown = function(e) {
				window.dragX = e.x
				window.dragY = e.y
				window.deltaX = 0
				window.deltaY = 0
				window.draging = true
			}
			window.onmouseup = function(e) { window.draging = false }
			window.onwheel = function(e) { gl.zoom(Math.sign(e.wheelDelta), e.x, e.y) }
        }
        function getEl(id) {
			var r = document.getElementById(id)
			if(!r) throw new Error("element [" + id + "] not found")
			return r
		}
        function getSurf() { return getEl("surface") }
        function getGl() {
			var surface = getSurf();
			if(!surface.gl) setupGL(surface);
			return surface.gl;
		}
		function getQuad(gl) {
			if(!gl.quad) {
				var bufId = gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER, bufId)
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 0,1, 1,1, 1,0]), gl.STATIC_DRAW)
				gl.quad = function(posAttrib) {
					gl.bindBuffer(gl.ARRAY_BUFFER, bufId)
					gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0)
					gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
				}
			}
			return gl.quad
		}
		function compile(s) {
			if(!s.shader) {
				var gl = getGl();
				var shader;
				if(s.type == "x-shader/x-vertex") shader = gl.createShader(gl.VERTEX_SHADER);
				else if(s.type == "x-shader/x-fragment") shader = gl.createShader(gl.FRAGMENT_SHADER);
				else return null;
				var src = '';
				for(c = s.firstChild; c; c = c.nextSibling) if(c.nodeType == c.TEXT_NODE) src += c.textContent;
				var vars = [];
				src.split('\n').forEach(function(line) {
					var parts = line.split("//");
					//var lastArray = parts.length > 1 && parts[1].trim() == "array";
					parts[0].split(";").forEach(function(statement) {
						var words = statement.split(/[^a-zA-Z0-9]/).filter(function(w) { return w.trim() });
						if(words[0] == "attribute") vars = vars.concat([{
							name : words[words.length-1],
							array: words.indexOf("array") >= 0,
							type : 'attribute'
						}])
						else if(words[0] == "uniform") vars = vars.concat([{
							name : words[words.length-1],
							type : 'uniform'
						}])
					})
				})
				gl.shaderSource(shader, src);
				gl.compileShader(shader);
				if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
					throw new Error("error in shader [" + s.id + "]\n" + gl.getShaderInfoLog(shader));
				s.shader = shader;
				s.vars = vars;
				//console.log("shader compiled: " + s.id + " => " + JSON.stringify(s.vars))
			}
			return s;
		}
        function entry() {
            var gl = getGl();
			gl.program = function(shaders) {
				if(!gl.progCache) gl.progCache = {}
				var key = shaders.toString();
				if(!gl.progCache[key]) {
					var prog = gl.createProgram();
					var vars = []
					shaders.forEach(function(s) {
						var shader = compile(getEl(s));
						vars = vars.concat(shader.vars)
						gl.attachShader(prog, shader.shader)
					})
					gl.linkProgram(prog)
					if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error("error in program [" + key + "]\n" + gl.getProgramInfoLog(prog));
					gl.useProgram(prog)
					prog.vars = {}
					vars.forEach(function(v) {
						if(v.type == 'attribute') {
							prog.vars[v.name] = gl.getAttribLocation(prog, v.name)
							if(v.array) gl.enableVertexAttribArray(prog, prog.vars[v.name]);
						} else if(v.type == 'uniform') {
							prog.vars[v.name] = gl.getUniformLocation(prog, v.name)
						}
						if(typeof(prog[v.name]) == "undefined") prog[v.name] = prog.vars[v.name]
					})
					//console.log("progam linked: " + key + " => " + JSON.stringify(prog.vars))
					gl.progCache[key] = prog
				} else gl.useProgram(gl.progCache[key])
				return gl.progCache[key]
			}
			init(gl)
			window.onresize()
        }
        function step() {
			draw(getGl())
			requestAnimationFrame(step)
        }
        
        /*function() {
			gl.
        }*/
		
		var config = {
			width: 1024,
			height: 1024,
			food_gen: 1,
			init: {
				density: 0.1,
				min_score: .1,
				max_score: .2,
				min_food: .2,
				max_food: .6
			},
			dna : [
				{
					name: "plant"
				},
				{
					name: "sheep"
				},
				{
					name: "wolf"
				}
			]
		}
        
		function init(gl) {
			gl.clearColor(0,0,0,1)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
			if(!(gl.draw_buffers = gl.getExtension("WEBGL_draw_buffers"))) throw new Error("no draw_buffers")
			if(!(gl.draw_buffers = gl.getExtension("WEBGL_depth_texture"))) throw new Error("no depth_texture")
			if(!(gl.draw_buffers = gl.getExtension("OES_texture_float"))) throw new Error("no texture_float")
			if(!(gl.draw_buffers = gl.getExtension("OES_texture_half_float"))) throw new Error("no texture_half_float")
			
			gl.camera = new Float32Array([0, 0, 20])
			gl.scroll = function(x,y) {
				gl.camera[0] -= x
				gl.camera[1] += y
			}
			gl.zoom = function(s, x,y) {
				var m = 1.1
				m = s == 0 ? 1 : s > 0 ? m : 1/m
				var target = gl.camera[2] * m
				if(target < 1) {
					target = 1
					m = target / gl.camera[2]
				}
				if(target > 150) {
					target = 150
					m = target / gl.camera[2]
				}
				gl.camera[2] = target
				s = 1 - 1/m
				gl.camera[0] += s * x
				gl.camera[1] += s * (gl.canvas.height - y)
				gl.camera[0] *= m
				gl.camera[1] *= m
			}
			gl.content = {}
			
			var n = config.width * config.height | 0
			var dna = new Uint8Array(new ArrayBuffer(n))
			var epf = new Float32Array(new ArrayBuffer(n * 4 * 3))
			var score_min = config.init.min_score * .5, score_delta = (config.init.max_score - config.init.min_score) * .5
			var food_min = config.init.min_food, food_delta = (config.init.max_food - config.init.min_food)
			for(var i = 0; i < n; i++) {
				if(Math.random() <= config.init.density) {
					var c = Math.floor(Math.random() * config.dna.length) | 0
					dna[i] = c + 1 | 0
					epf[3 * i] = epf[3*i+1] = score_min + score_delta * Math.random()
				} else {
					dna[i] = 0
					epf[3 * i] = epf[3*i+1] = 0
				}
				epf[3*i+2] = food_min + Math.random() * food_delta
			}
			
			function setLinear() {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
			}
			function setNearest() {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
			}
			function setRepeat() {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
			}
			
			gl.bindTexture(gl.TEXTURE_2D, gl.content.dna = gl.createTexture())
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, config.width, config.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, dna)
			setNearest(); setRepeat()
			
			gl.bindTexture(gl.TEXTURE_2D, gl.content.epf = gl.createTexture())
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, config.width, config.height, 0, gl.RGB, gl.FLOAT, epf)
			setNearest(); setRepeat()
			
			/*gl.screen = gl.createFramebuffer()
			gl.bindFramebuffer()
			gl.framebufferTexture2d()
			
			gl.genRenderbuffers(1)
			gl.framebufferRenderbuffer()*/
			
			//console.log(getGl().getSupportedExtensions())
		}
		function resize(gl) {
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
		}
        function draw(gl) {
			//gl.clear(gl.COLOR_BUFFER_BIT)
			
			gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, gl.content.dna)
			gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, gl.content.epf)
			
			var prog = gl.program(["2d", "draw"])
			gl.uniform1f(prog.time, performance.now())
			gl.uniform3fv(prog.camera, gl.camera)
			gl.uniform2fv(prog.invSize, [ 1 / config.width, 1 / config.height ])
			gl.uniform1i(prog.dna, 0)
			gl.uniform1i(prog.epf, 1)
			getQuad(gl)(prog.posIn)
		}
    </script>
	<script type="x-shader/x-vertex" id="2d">
		uniform float time;
		attribute vec2 /* array */ posIn;
		void main(void) {
			gl_Position = vec4(posIn * vec2(2) - vec2(1), vec2(0,1));
		}
	</script>
	<script type="x-shader/x-fragment" id="draw">
		precision mediump float;
		uniform vec3 camera;
		uniform vec2 invSize;
		uniform sampler2D dna, epf;
		#define pi2 6.28318530718
		vec3 hue(float h) {
			return clamp(vec3(
				6.0 * abs(h-.5) - 1.0,
				2.0 - 6.0 * abs(h - .33333333333333),
				2.0 - 6.0 * abs(h - .66666666666667)
			), vec3(0.0), vec3(1.0));
		}
		void main(void) {
			//gl_FragCoord
			vec2 trans = (gl_FragCoord.xy + camera.xy) / camera.z;
			
			vec2 grid1 = step( vec2(1. - .2/camera.z), cos(trans * vec2(pi2)) );
			vec2 grid10 = step( vec2(1. - .05/camera.z), cos(trans * vec2(.1*pi2)) );
			vec2 grid100 = step( vec2(1. - .01/camera.z), cos(trans * vec2(.01*pi2)) );
			vec2 grid2 = grid100 * grid10 + grid10 * clamp(.2 * (camera.z - 5.), 0., 1.) + grid1 * clamp(.01 * (camera.z - 50.), 0., 1.);
			float grid = min(1., grid2.x + grid2.y);
			
			vec2 texCoord = trans * invSize;
			float dna_ = texture2D(dna, texCoord).a;
			vec3  epf_ = texture2D(epf, texCoord).rgb;
			vec3 color;
			if(dna_ != 0.) { // draw cell
				color = hue(fract(dna_ * 70.));
				vec3 fill = color * epf_.r;
				if(max(abs(fract(trans.x) - .5), abs(fract(trans.y) - .5)) > (.5 - epf_.g * .5)) { // border
					color = mix(fill, (color + vec3(1.)) * .5, clamp((camera.z - 20.) * .02, 0., 1.));
				} else { // fill
					color = fill;
				}
				//color =  * min(value, .5) * 2. + max(value - .5, 0.0) * vec3(2.0);
			} else { // draw food
				float fill = epf_.b * .5;
				if(camera.z > 15.) {
					float pattern = mod(floor(trans.x) + floor(trans.y), 2.) == 0. ? trans.x + trans.y : trans.x - trans.y;
					pattern = .5 + .5 * cos(pattern * pi2 * 4.);
					pattern = epf_.b < .5 ? .25 * step(pattern, epf_.b * 2.) : .25 + .25 * step(epf_.b * 2. - 1., pattern);
					color = vec3(mix(fill, pattern, min((camera.z - 15.) * .01, 1.)));
				} else color = vec3(fill);
			}
			gl_FragColor = vec4(vec3(color + vec3(grid * .4)), 1);
		}
	</script>

</head><body onload="entry()">
    <canvas id="surface">
        No WebGL!
    </canvas>
</body></html>
